#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "cmr" "default"
\font_sans "cmss" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a5paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 2cm
\rightmargin 1.5cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 1 0 9 -1
\bullet 2 0 26 -1
\bullet 3 0 12 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
MelonC Programming Language Specificaion
\end_layout

\begin_layout Author
Knot126
\end_layout

\begin_layout Date
2023-09-08, version 0.0.1
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
With Melon, I am intending to create a simple, usable and intuitive core
 library that covers many things in the context of game devleopment.
 (Though, we don't try to make it a game development library specifically,
 but it's targeted to that, and must meet some minium constraints to do
 that.) Stated a bit differently, the goal of Melon is to be a simple core
 library that replaces the standard but very limited C library with something
 modern and intuitive.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Why C?
\begin_inset Quotes erd
\end_inset

 This is actually quite easy to answer: C is a relatively simple and elegant
 language that is quite close to the hardware.
 That is to say, for the time it was designed and for it's current position
 as 
\begin_inset Quotes eld
\end_inset

not C++
\begin_inset Quotes erd
\end_inset

, it works very well.
 However, it's not a perfect language.
 It would be nice, for example, if the perprocessor syntax were different,
 and if the language were really headerless, perhaps realloc(ptr, 0) could
 be defined, or maybe even if there was an option to automatically free
 allocated memory.
 And of course, some limited set of other modern features like structures
 with methods and operator overloading would be nice to simplify development,
 as well.
\end_layout

\begin_layout Standard
The MelonC language aims to be this.
 We don't want to make C++ again, and we don't want to make an overly complex
 language, but we 
\emph on
do
\emph default
 want a modern language with comfortable features.
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Subsection
Overview of this Document
\end_layout

\begin_layout Standard
The MelonC language is mostly specified in terms of differences to C rather
 than standalone.
 This should make it easier to develop MelonC compilers that depend on C
 compiler backends which might not support the latest version of standard
 C.
\end_layout

\begin_layout Subsection
Overview of Changes
\end_layout

\begin_layout Standard
The main additions of MelonC include:
\end_layout

\begin_layout Itemize
Functions in structures (methods)
\end_layout

\begin_layout Itemize
Operator overloading
\end_layout

\begin_layout Itemize
Type generics
\end_layout

\begin_layout Itemize
Reworked file inclusion and preprocessor
\end_layout

\begin_layout Itemize
Better defined operations
\end_layout

\begin_layout Itemize
Hybrid and full automatic free
\end_layout

\begin_layout Itemize
Better core library via Melon
\end_layout

\begin_layout Subsubsection
Functions in structures
\end_layout

\begin_layout Standard
In MelonC, you can declare methods (functions in structure) and use some
 syntax sugar to call them.
 For example:
\end_layout

\begin_layout Verbatim

struct Array {
\end_layout

\begin_layout Verbatim

    int *memory;
\end_layout

\begin_layout Verbatim

    size_t length;
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

    // This is a constructor, a special function which is called
\end_layout

\begin_layout Verbatim

    // as part of initialising the structure.
 It must return 
\end_layout

\begin_layout Verbatim

    // void.
\end_layout

\begin_layout Verbatim

    void init(Array *this) {
\end_layout

\begin_layout Verbatim

        int *m;
\end_layout

\begin_layout Verbatim

        m = malloc(16);
\end_layout

\begin_layout Verbatim

        m[0] = m[1] = m[2] = m[3] = 0xf00;
\end_layout

\begin_layout Verbatim

        this->memory = m;
\end_layout

\begin_layout Verbatim

    }
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

    int at(Array* this, size_t i) {
\end_layout

\begin_layout Verbatim

        return this->memory[i];
\end_layout

\begin_layout Verbatim

    }
\end_layout

\begin_layout Verbatim

}
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

int main(int argc, const char *argv[]) {
\end_layout

\begin_layout Verbatim

    Array arr(); // This calls the `Array.init` function with 
\end_layout

\begin_layout Verbatim

                 // `this` being a pointer `arr`.
\end_layout

\begin_layout Verbatim

    printf(
\begin_inset Quotes eld
\end_inset

%d
\begin_inset Quotes erd
\end_inset

, arr.at(2)); // Calls `Array.at` with `this`
\end_layout

\begin_layout Verbatim

                             // being a pointer to `arr` and `i`
\end_layout

\begin_layout Verbatim

                             // being 2.
\end_layout

\begin_layout Verbatim

    Array *arr_ptr = &arr;
\end_layout

\begin_layout Verbatim

    printf(
\begin_inset Quotes eld
\end_inset

%d
\begin_inset Quotes erd
\end_inset

, arr_ptr->at(2)); // Same as above, but `arr` is 
\end_layout

\begin_layout Verbatim

                              // already a pointer.
\end_layout

\begin_layout Verbatim

    return 0;
\end_layout

\begin_layout Verbatim

}
\end_layout

\begin_layout Subsubsection
Operator (and thus function) overloading
\end_layout

\begin_layout Standard
It is possible to overload functions and operators to have a more convient
 way to handle standard operations on custom types.
\end_layout

\begin_layout Verbatim

struct Array {
\end_layout

\begin_layout Verbatim

    // ...
 struct and init from earlier ...
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

    // The 
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

 operator is the access operator
\end_layout

\begin_layout Verbatim

    int 
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

(Array* this, size_t i) {
\end_layout

\begin_layout Verbatim

        return this->memory[i];
\end_layout

\begin_layout Verbatim

    }
\end_layout

\begin_layout Verbatim

}
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

int main(int argc, const char *argv[]) {
\end_layout

\begin_layout Verbatim

    Array arr();
\end_layout

\begin_layout Verbatim

    printf(
\begin_inset Quotes eld
\end_inset

%d
\begin_inset Quotes erd
\end_inset

, arr[2]); // Same as .at, but uses the operator
\end_layout

\begin_layout Verbatim

    Array *arr_ptr = &arr;
\end_layout

\begin_layout Verbatim

    printf(
\begin_inset Quotes eld
\end_inset

%d
\begin_inset Quotes erd
\end_inset

, arr_ptr[0][2]);
\end_layout

\begin_layout Verbatim

    return 0;
\end_layout

\begin_layout Verbatim

}
\end_layout

\begin_layout Subsubsection

Type generics
\end_layout

\begin_layout Standard

Types (and functions!) can have templates or generics:
\end_layout

\begin_layout Verbatim

struct Array(Type) {
\end_layout

\begin_layout Verbatim

    Type *memory;
\end_layout

\begin_layout Verbatim

    size_t length;
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

    void init(Array *this) {
\end_layout

\begin_layout Verbatim

        Type *m;
\end_layout

\begin_layout Verbatim

        m = malloc(sizeof(Type) * 4);
\end_layout

\begin_layout Verbatim

        m[0] = m[1] = m[2] = m[3] = 0xf00;
\end_layout

\begin_layout Verbatim

        this->memory = m;
\end_layout

\begin_layout Verbatim

    }
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

    Type 
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

(Array* this, size_t i) {
\end_layout

\begin_layout Verbatim

        return this->memory[i];
\end_layout

\begin_layout Verbatim

    }
\end_layout

\begin_layout Verbatim

}
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

int main(int argc, const char *argv[]) {
\end_layout

\begin_layout Verbatim

    Array(uint64_t) arr();
\end_layout

\begin_layout Verbatim

    printf(
\begin_inset Quotes eld
\end_inset

0x%x
\begin_inset Quotes erd
\end_inset

, arr[2]);
\end_layout

\begin_layout Verbatim

    Array(uint64_t) *arr_ptr = &arr;
\end_layout

\begin_layout Verbatim

    printf(
\begin_inset Quotes eld
\end_inset

0x%x
\begin_inset Quotes erd
\end_inset

, arr_ptr[0][2]));
\end_layout

\begin_layout Verbatim

    return 0;
\end_layout

\begin_layout Verbatim

}
\end_layout

\begin_layout Subsubsection

Reworked preprocessor
\end_layout

\begin_layout Standard

The preprocessor is basically removed; instead, we use 
\begin_inset Quotes eld
\end_inset

attributes
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Verbatim

@import(
\begin_inset Quotes eld
\end_inset

Integer.me
\begin_inset Quotes erd
\end_inset

) // An import attribute
\end_layout

\begin_layout Verbatim

@import 
\begin_inset Quotes eld
\end_inset

IO.me
\begin_inset Quotes erd
\end_inset

 // Single symbols, numbers and strings
\end_layout

\begin_layout Verbatim

                // won't need brackets
\end_layout

\begin_layout Verbatim

@import 
\begin_inset Quotes eld
\end_inset

Memory.me
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

struct Array(Type) {
\end_layout

\begin_layout Verbatim

    Type *memory;
\end_layout

\begin_layout Verbatim

    size_t length;
\end_layout

\begin_layout Verbatim

...
\end_layout

\begin_layout Subsubsection
Better core library
\end_layout

\begin_layout Standard
MelonC uses Melon as the core library, a simple and intuitive core library.
\end_layout

\begin_layout Verbatim

@import 
\begin_inset Quotes eld
\end_inset

SimpleCrypto.me
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Verbatim

@import 
\begin_inset Quotes eld
\end_inset

Log.me
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Verbatim

@import 
\begin_inset Quotes eld
\end_inset

string.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

int main(int argc, const char *argv[]) {
\end_layout

\begin_layout Verbatim

    const char *data = 
\begin_inset Quotes eld
\end_inset

This is the data which I wish to encrypt
\begin_inset Quotes erd
\end_inset

;
\end_layout

\begin_layout Verbatim

    DgCryptoKey(256) key(
\end_layout

\begin_layout Verbatim

        {0xcd, 0xb6, 0x25, 0x9c, 0xcd, 0xb6, 0x25, 0x9c,
\end_layout

\begin_layout Verbatim

         0x57, 0x88, 0x81, 0x3d, 0x57, 0x88, 0x81, 0x3d,
\end_layout

\begin_layout Verbatim

         0xb2, 0x15, 0xb5, 0xa6, 0xb2, 0x15, 0xb5, 0xa6,
\end_layout

\begin_layout Verbatim

         0x0f, 0x32, 0x38, 0xf8, 0x0f, 0x32, 0x38, 0xf8}
\end_layout

\begin_layout Verbatim

    );
\end_layout

\begin_layout Verbatim

    DgNonce(96) nonce;
\end_layout

\begin_layout Verbatim

    nonce.randomise();
\end_layout

\begin_layout Verbatim

	
\end_layout

\begin_layout Verbatim

    DgCryptoCiphertext *t = DgCryptoEncrypt_ChaCha20_Poly1305(
\end_layout

\begin_layout Verbatim

        key,
\end_layout

\begin_layout Verbatim

        strlen(data),
\end_layout

\begin_layout Verbatim

        data,
\end_layout

\begin_layout Verbatim

    );
\end_layout

\begin_layout Verbatim

	
\end_layout

\begin_layout Verbatim

    DgLog(DG_LOG_VERBOSE, 
\begin_inset Quotes eld
\end_inset

Ciphertext:
\backslash
n
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim

    print_bytes(t->data_length, t->data);
\end_layout

\begin_layout Verbatim

    DgLog(DG_LOG_VERBOSE, 
\begin_inset Quotes eld
\end_inset

Nonce:
\backslash
n
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim

    print_bytes(t->nonce_length, t->nonce);
\end_layout

\begin_layout Verbatim

    DgLog(DG_LOG_VERBOSE, 
\begin_inset Quotes eld
\end_inset

MAC:
\backslash
n
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Verbatim

    print_bytes(t->mac_length, t->mac);
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

    return 0;
\end_layout

\begin_layout Verbatim

}
\end_layout

\begin_layout Verbatim

\end_layout

\end_body
\end_document
